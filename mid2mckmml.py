#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2012, C-yan
#
# Permission to use, copy, modify, and/or distribute this software for
# any purpose with or without fee is hereby granted, provided that the 
# above copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# create .mml from .mid which is generated by nsf2midi
# usage: ./mid2mckmml.py input.mid

from sys import exit, stdout, stderr, argv

def readv(f):
  v = 0
  while True:
    t = ord(f.read(1))
    if (t & 0x80) == 0:
      return (v << 7) + t
    else:
      v = (v << 7) + t

def finish():
  del penvresult[(0, 0)]
  ptab = {}
  for k in penvresult:
    ptab[penvresult[k]] = k
  for i in sorted(ptab.keys()):
    stdout.write("@EP%d = { %s }\n" % (i, ' '.join(str(v) for v in ptab[i]))) # TODO: reduce pitch envelope
  vtab = {}
  for k in venvresult:
    vtab[venvresult[k]] = k
  for i in sorted(vtab.keys()):
    stdout.write("@v%d = { %s }\n" % (i, ' '.join(str(v) for v in vtab[i]))) # TODO: reduce volume envelope
  stdout.write("A t30q8@2%s\n" % result[0]) # TODO: set valid duty cycle
  stdout.write("B t30q8@2%s\n" % result[1]) # TODO: set valid duty cycle
  stdout.write("C t30q8%s\n" % result[2])
  exit(0)

def meta(f):
  t = ord(f.read(1))
  if t in [1, 2, 3, 4, 5]:
    debug("%d Meta %d" % (p, t))
    f.read(readv(f))
  elif t == 0x51:
    debug("%d Meta Tempo" % p)
    f.read(4)
  elif t == 0x2f:
    if ord(f.read(1)) == 0:
      debug("%d Meta Finish" % p)
      finish()
    else:
      debug("%d Meta Finish Error" % p)
      exit(1)
  else:
    debug("%d Meta Unknown %s" % (p, hex(t)))
    exit(1)

def sysex(t):
  debug("%d SysEx" % (p))
  f.read(readv(f))

def note_on(t):
  ch = t & 0x0f
  note = ord(f.read(1))
  vel = ord(f.read(1))
  l = p - noteon[ch][0]
  if l != 0:
    result[ch] += " r#%d" % l
  noteon[ch] = [p, note, vel]
  debug("%d On ch=%d n=%d v=%d" % (p, ch + 1, note, vel))

def control_change(t):
  ch = t & 0x0f
  v1 = ord(f.read(1))
  v2 = ord(f.read(1))
  if v1 == 11: # expression
    venv[ch] += [(p, voltable[v2])]
  debug("%d CC ch=%d v1=%d v2=%d" % (p, ch + 1, v1, v2))

def program_change(t):
  debug("%d Program Change: %d" % (p, ord(f.read(1))))

def pitch_bend(t):
  ch = t & 0x0f
  t = f.read(2)
  v = ord(t[0]) + (ord(t[1]) << 7) - 8192
  penv[ch] += [(p, int(v / 128.0 + 0.5))] # TODO: fix dirty hack
  debug("%d Pitch Bend ch=%d v=%d" % (p, ch, v))

def note_off(t):
  ch = t & 0x0f
  note = ord(f.read(1))
  vel = ord(f.read(1))

  result[ch] += " "

  # volume envelope
  if ch in [0, 1]:
    ne = []
    for i in range(len(venv[ch]) - 1):
      ne += [venv[ch][i][1]] * (venv[ch][i + 1][0] - venv[ch][i][0])
    ne += [venv[ch][-1][1]]
    ne = tuple(ne)
    if not (ne in venvresult):
      venvresult[ne] = len(venvresult)
    result[ch] += "@v%d" % venvresult[ne]
    venv[ch] = []

  # pitch envelope
  pe = [penv[ch][0][1]]
  for i in range(len(penv[ch]) - 1):
    pe += [0] * (penv[ch][i + 1][0] - penv[ch][i][0] - 1) + [penv[ch][i + 1][1] - penv[ch][i][1]]
  if all(map(lambda x: x == pe[0], pe[1:])):
    pe = [pe[0]]
  pe = tuple(pe + [0])
  if not (pe in penvresult):
    penvresult[pe] = len(penvresult) - 1
  if penvresult[pe] != -1:
    result[ch] += "EP%d" % penvresult[pe]
  penv[ch] = []

  # nsf2midi default: t30, r4 = 120 delta
  # 1 delta = %1 / (120 * 48) on t30, so 1 delta = %1 on t75
  # 1 delta = 1 frame = 1 / 60 sec
  o = (noteon[ch][1] / 12) - 1
  nt = notetable[noteon[ch][1] % 12]
  l = p - noteon[ch][0]
  noteon[ch][0] = p
  result[ch] += "o%d%s#%d" % (o, nt, l) # TODO: reduce octave

  debug("%d Off ch=%d n=%d v=%d" % (p, ch + 1, note, vel))

def debug(v):
  if debug_on:
    print >> stderr, v

debug_on = False

# lookups
voltable = { 127: 15, 122: 14, 118: 13, 113: 12, 108: 11, 103: 10, 98: 8, 92: 8, 86: 7, 80: 6, 73: 5, 65: 4, 56: 3, 46: 2, 32: 1, 0: 0 }
notetable = [ 'c', 'c+', 'd', 'd+', 'e', 'f', 'f+', 'g', 'g+', 'a', 'a+', 'b' ]

# global variables
p = 0
result = ["", "", ""]
noteon = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
venvresult = {}
venv = [[], []]
penvresult = {(0, 0): -1}
penv = [[], [], []]

f = open(argv[1])
f.read(14) # skip MThd
f.read(8)  # skip MTrk

while True:
  p += readv(f)
  t = ord(f.read(1))
  if t == 0xFF:
    meta(f)
  elif (t == 0xf0) or (t == 0xf7):
    sysex(t)
  elif (t & 0xf0) == 0x80:
    note_off(t)
  elif (t & 0xf0) == 0x90:
    note_on(t)
  elif (t & 0xf0) == 0xb0:
    control_change(t)
  elif (t & 0xf0) == 0xc0:
    program_change(t)
  elif (t & 0xf0) == 0xe0:
    pitch_bend(t)
  else:
    debug("%d Unknown %d" % (p, hex(t)))
    exit(1)
